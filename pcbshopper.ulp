/**
 * @file pcbshopper.ulp
 * @brief Automatically parse PCB and submit for quote on PCBshopper.com
 *
 * @author Jeremy Ruhland <jeremy ( a t ) goopypanther.org>
 * @license (C) Jeremy Ruhland 2016 under GPL3
 *
 */
 
#usage "<b>PCBshopper Quote Helper</b>"
       "<p>"
       "Automatically submit quotes to PCBshopper.com"
       "<p>"
       "<author>Author: Jeremy Ruhland</author>"
       
#require 5.1000
string Version = "1";


// Defines
enum {
    false = 0,
    true  = 1
};

// Dimention units
enum {
    inches = 0,
    cm     = 1,
    mm     = 2
};

// Silkscreen
enum {
    no     = 0,
    top    = 1,
    bottom = 2,
    both   = 3
};

// User generated layers
enum {
    LAYER_TSILK = 121,
    LAYER_BSILK = 122
};


// Global variables
char skipDrcExport;
string druFilePath;
string paramWarnings;

// Params for API
real pcbShopperWidth; // Board width
real pcbShopperHeight; // Board height
char pcbShopperUnits; // Dim measurement units
int pcbShopperLayers; // Board layers
// Solder mask color, unimplemented, no good way to get data from eagle
char pcbShopperSilkscreen; // Silkscreen number
// Copper finish type, unimplemented, assumed cheapest
// Copper weight, unimplemented, parsing dru files too annoying
real pcbShopperTrace; // Min trace thickness
char pcbShopperTwUnits; // Trace thickness units
real pcbShopperDrill; // Min drill size
char pcbShopperDrillUnits; // Drill size units
int pcbShopperFingers; // Number of hard gold finish parts
// Stencil, unimplemented, assumed no
// Quality, unimplemented, assumed not required
// Designs, unimplemented, assumed 1
// Country, unimplemented, assumed US
// Days, unimplemented, assumed default


// Functions

/**
 * Wrap string in list tags
 * 
 * @param item String to wrap
 * @return Wrapped string
 */
string listWrap(string item) {
    return ("<li>" + item + "</li>");
}


/**
 * Calculate PCB parameters required for quote
 * TODO
 */
void calculateParams(void) {
    char tSilk = false;
    char bSilk = false;
    char tFinish = false;
    char bFinish = false;
    
    // Check layer usage
    board(B) { // Create board context for layer usage check
        B.layers(L) { // Loop context for each layer
            // Count each copper layer used
            if (L.number <= 16) {
                pcbShopperLayers++;
            // Catch silk layers
            } else if ((L.number == LAYER_TPLACE) || (L.number == LAYER_TSILK)) {
                tSilk = true;
            } else if ((L.number == LAYER_BPLACE) || (L.number == LAYER_BSILK)) {
                bSilk = true;
            // Catch gold finish
            } else if (L.number == LAYER_TFINISH) {
                tFinish = true;
            } else if (L.number == LAYER_BFINISH) {
                bFinish = true;
            } else {}
        }
    }
    
    if ((tSilk == true) && (bSilk == true)) {
        pcbShopperSilkscreen = both;
    } else if (tSilk == true) {
        pcbShopperSilkscreen = top;
    } else if (bSilk == true) {
        pcbShopperSilkscreen = bottom;
    } else {
        pcbShopperSilkscreen = no;
    }

    if (pcbShopperLayers == 0) {
        paramWarnings += listWrap("No traces found on copper layers.");
    } else {}

    // Measure board dims from outline
    // Or from outer layers
    
    // Find minimum trace width
    int smallestTrace = INT_MAX; // Will lose to any other real trace
    
    board(B) { // Board context
        B.signals(S) { // Loop through all signals
            S.wires(W) { // Loop through each wire
                if (W.layer <= 16) { // Check if on copper layers
                    smallestTrace = min(smallestTrace, W.width); // Find thinest trace
                } else {}
            }
            
            /* Check S.polygons for width? Thinking no, poly width not correlated to
             * actual width, ie. zero width polygons
             */ 
        }

        B.wires(W) { // Loop through all wires
            if (W.layer <= 16) { // Check if on copper layers
                smallestTrace = min(smallestTrace, W.width); // Find thinest trace
            } else {}
        }
    }
    
    pcbShopperTrace = u2mm(smallestTrace); // Convert internal units to mm
    pcbShopperTwUnits = mm;
    
    // Pull params out of DRU
    
    // Check hole sizes
    int smallestHole = INT_MAX; // Will lose to any other real hole
    
    board(B) { // Board context
        B.holes(H) { // Loop through board holes
            smallestHole = min(smallestHole, H.drill); // Find smallest drill
        }
        
        B.signals(S) {
            S.vias(V) {
                smallestHole = min(smallestHole, V.drill); // Find any via smaller than hole
            }
        }
        
        B.elements(E) { // Loop through each object on PCB
            E.package.contacts(C) { // Loop through each contact of each package
                if (C.pad) {
                    smallestHole = min(smallestHole, C.pad.drill); // Find contacts smaller than hole
                } else {}
            }
            
            E.package.holes(H) { // Loop through holes in each package
                smallestHole = min(smallestHole, H.drill); // Find holes smaller than others
            }
        }
    }
    
    pcbShopperDrill = u2mm(smallestHole); // Convert internal units to mm
    pcbShopperDrillUnits = mm;
    
    // Check for unrouted nets
    char ratsnestExist = false;
    
    board(B) { // Board context
        B.wires(W) { // Loop & check for unrouted wires
            if (W.layer == LAYER_UNROUTED) {
                ratsnestExist = true;
            } else {}
        }
        
        B.signals(S) {
            S.wires(W) { // Loop & check for unrouted signal wires
                if (W.layer == LAYER_UNROUTED) {
                    ratsnestExist = true;
                } else {}
            }
            
            S.polygons(P) { // Loop & check for unrouted polygons
                if (P.layer == LAYER_UNROUTED) {
                    ratsnestExist = true;
                } else {}
            }
        }
    }
    
    if (ratsnestExist == true) {
        paramWarnings += listWrap("There are unrouted nets on the PCB.");
    } else {}
    
    // Count hard gold finish pads (just the polygons and rectangles)
    char finishLayersUsed = false;
    pcbShopperFingers = 0;
    
    board(B) { // Board context
        // Check if either finish layer used
        B.layers(L) { // Loop through each layer
            if ((L.number == LAYER_TFINISH) || (L.number == LAYER_BFINISH)) {
                finishLayersUsed = true;
            } else {}
        }
        
        // Only run further counts if finish layers were used
        if (finishLayersUsed) {
            B.elements(E) { // Loop through each object
                E.package.polygons(P) { // Loop through each polygon of each package
                    if ((P.layer == LAYER_TFINISH) || (P.layer == LAYER_BFINISH)) {
                        pcbShopperFingers++;
                    } else {}
                }
                
                E.package.rectangles(R) { // Loop through each rectangle of each package
                    if ((R.layer == LAYER_TFINISH) || (R.layer == LAYER_BFINISH)) {
                        pcbShopperFingers++;
                    } else {}
                }
            }
            
            B.polygons(P) { // Loop through each polygon
                if ((P.layer == LAYER_TFINISH) || (P.layer == LAYER_BFINISH)) {
                    pcbShopperFingers++;
                } else {}
            }
            
            B.rectangles(R) { // Loop through each rectangle
                if ((R.layer == LAYER_TFINISH) || (R.layer == LAYER_BFINISH)) {
                    pcbShopperFingers++;
                } else {}
            }
        } else {}
    }
}


/**
 * Draw dialog with quote information
 * TODO
 */
void drawDialog(void) {

}


/**
 * Main function executed from here
 */

// Parse arguments & search for state indicator
skipDrcExport = false;
for (int i = 1; i <= argc; i++) {
    if (argv[i] == "-skipDrcExport") {
        skipDrcExport = true;
    } else {}
}

// Check we are in layout editor...
if (board) {
    // Export board design rules to temp file unless specified by runtime flag
    if (skipDrcExport == false) {
        board(B) { // Create context
            // Generate file path for new temp dru file
            druFilePath = filedir(argv[0]) + "pcbshpr-" + filename(filesetext(B.name, ".dru"));

            // Save drc file, re-run script with new directive
            exit("DRC SAVE '" + druFilePath + "';\nRUN '" + argv[0] + "' -skipDrcExport;");
        }
    } else {
    // If dru already exported in previous run
        status("Identifying PCB design constraints...");
        calculateParams(); // Check PCB for all relevant design constraints
        
        // Check if any warnings were generated during param calcs
        if (paramWarnings) {
            // Generate warning string for display
            paramWarnings = "<b>Warnings generated during param calcs:</b> <ul>" + paramWarnings + "</ul>";
        } else {}

        drawDialog(); // Display info dialog with params

        exit(EXIT_SUCCESS);
	}
// If we are not in layout editor...
} else {
    // Popup warning
    dlgMessageBox("This script must be run from layout editor.");
}
