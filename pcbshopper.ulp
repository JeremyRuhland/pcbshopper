/**
 * @file pcbshopper.ulp
 * @brief Automatically parse PCB and submit for quote on PCBshopper.com
 *
 * @author Jeremy Ruhland <jeremy ( a t ) goopypanther.org>
 * @license (C) Jeremy Ruhland 2016 under GPL3
 *
 */
 
#usage "<b>PCBshopper Quote Helper</b>"
       "<p>"
       "Automatically submit quotes to PCBshopper.com"
       "<p>"
       "<author>Author: Jeremy Ruhland</author>"
       
#require 5.1000
string Version = "1";


// Defines
enum {
    false = 0,
    true  = 1
};

// Dimention units
enum {
    inches = 0,
    cm     = 1,
    mm     = 2
};

// Silkscreen
enum {
    no     = 0,
    top    = 1,
    bottom = 2,
    both   = 3
};

// User generated layers
enum {
    LAYER_TSILK = 121,
    LAYER_BSILK = 122
};


// Global variables
string paramWarnings;

// Params for API
real pcbShopperWidth; // Board width
real pcbShopperHeight; // Board height
char pcbShopperUnits; // Dim measurement units
int pcbShopperLayers; // Board layers
// Solder mask color, unimplemented, no good way to get data from eagle
char pcbShopperSilkscreen; // Silkscreen number
// Copper finish type, unimplemented, assumed cheapest
// Copper weight, unimplemented, parsing dru files too annoying
real pcbShopperTrace; // Min trace thickness
char pcbShopperTwUnits; // Trace thickness units
real pcbShopperDrill; // Min drill size
char pcbShopperDrillUnits; // Drill size units
int pcbShopperFingers; // Number of hard gold finish parts
// Stencil, unimplemented, assumed no
// Quality, unimplemented, assumed not required
// Designs, unimplemented, assumed 1
// Country, unimplemented, assumed US
// Days, unimplemented, assumed default


// Functions

/**
 * Wrap string in list tags
 * 
 * @param item String to wrap
 * @return Wrapped string
 */
string listWrap(string item) {
    return ("<li>" + item + "</li>");
}


/**
 * Calculate PCB parameters required for quote
 *
 * Currently calculates (in order):
 *  1. Copper layer count
 *  2. Silkscreen layer usage
 *  3. Outer board dimensions using board outline layer
 *      (taking into account wire width)
 *  4. Minimum trace width
 *  5. Smallest drill size
 *  6. Unrouted nets
 *  7. Hard gold finish objects
 *
 * Everything is stored into pcbShopper global variables, mm where applicable
 */
void calculateParams(void) {
    char tSilk = false;
    char bSilk = false;
    char tFinish = false;
    char bFinish = false;
    
    // Check layer usage
    board(B) { // Create board context for layer usage check
        B.layers(L) { // Loop context for each layer
            // Count each copper layer used
            if ((L.number <= 16) && (L.used == true)) {
                pcbShopperLayers++;
            // Catch silk layers
            } else if (((L.number == LAYER_TPLACE) || (L.number == LAYER_TSILK)) && (L.used == true)) {
                tSilk = true;
            } else if (((L.number == LAYER_BPLACE) || (L.number == LAYER_BSILK)) && (L.used == true)) {
                bSilk = true;
            } else {}
        }
    }
    
    if ((tSilk == true) && (bSilk == true)) {
        pcbShopperSilkscreen = both;
    } else if (tSilk == true) {
        pcbShopperSilkscreen = top;
    } else if (bSilk == true) {
        pcbShopperSilkscreen = bottom;
    } else {
        pcbShopperSilkscreen = no;
    }

    if (pcbShopperLayers == 0) {
        paramWarnings += listWrap("No traces found on copper layers.");
    } else {}

    // Measure board dims from outline
    int xMin, xMax, yMin, yMax;
    char initialObj = true;

    
    board(B) { // Create board context
        B.layers(L) { // Loop for each layer
            // If dimension layer is unused, generate warning
            if ((L.number == LAYER_DIMENSION) && (L.used == false)) {
                paramWarnings += listWrap("No dimension layer found, board must have dimension for quote.");
            } else {}
        }
        
        B.wires(W) { // Loop through wires
            // If wire is on dimension layer
            if (W.layer == LAYER_DIMENSION) {
                if (initialObj == true) { // Catch initial wire so min/max is init'd *somewhere* on board edge
                    initialObj = false;

                    xMin = W.x1;
                    yMin = W.y1;

                    xMax = W.x1;
                    yMax = W.y1;
                } else {}

                xMin = min(xMin, (W.x1 - (W.width / 2)));
                xMin = min(xMin, (W.x2 - (W.width / 2)));

                xMax = max(xMax, (W.x1 + (W.width / 2)));
                xMax = max(xMax, (W.x2 + (W.width / 2)));

                yMin = min(yMin, (W.y1 - (W.width / 2)));
                yMin = min(yMin, (W.y2 - (W.width / 2)));

                yMax = max(yMax, (W.y1 + (W.width / 2)));
                yMax = max(yMax, (W.y2 + (W.width / 2)));

                // If wire is an arc additional checks must be performed to find actual min/max
                if (W.arc) { // If wire is arc, calculate bounding box of arc
                    xMin = min(xMin, (W.arc.xc - W.arc.radius - (W.arc.width / 2)));
                    yMin = min(yMin, (W.arc.yc - W.arc.radius - (W.arc.width / 2)));

                    xMax = max(xMax, (W.arc.xc + W.arc.radius + (W.arc.width / 2)));
                    yMax = max(yMax, (W.arc.yc + W.arc.radius + (W.arc.width / 2)));
                } else {}
            } else {}
        }
        
        // In the event the board outline is made of a single circle...
        B.circles(C) { // Loop through circles
            if (C.layer == LAYER_DIMENSION) {
                if (initialObj == true) { // Catch initial object so min/max starts at center of board
                    initialObj = false;

                    xMin = C.x;
                    yMin = C.y;

                    xMax = C.x;
                    yMax = C.y;
                } else {}
                
                // Check against min/max so internal circular cutouts don't overwrite actual board edge 
                xMin = min(xMin, (C.x - C.radius - (C.width / 2)));
                yMin = min(yMin, (C.y - C.radius - (C.width / 2)));

                xMax = max(xMax, (C.x + C.radius + (C.width / 2)));
                yMax = max(yMax, (C.y + C.radius + (C.width / 2)));
            }
        }
    }
    
    // Find board dims from min/max points & convert internal units to mm
    pcbShopperWidth = u2mm(xMax - xMin);
    pcbShopperHeight = u2mm(yMax - yMin);
    pcbShopperUnits = mm;

    // Find minimum trace width
    int smallestTrace = INT_MAX; // Will lose to any other real trace
    
    board(B) { // Board context
        B.signals(S) { // Loop through all signals
            S.wires(W) { // Loop through each wire
                if (W.layer <= 16) { // Check if on copper layers
                    smallestTrace = min(smallestTrace, W.width); // Find thinest trace
                } else {}
            }
            
            /* Check S.polygons for width? Thinking no, poly width not correlated to
             * actual width, ie. zero width polygons
             */ 
        }

        B.wires(W) { // Loop through all wires
            if (W.layer <= 16) { // Check if on copper layers
                smallestTrace = min(smallestTrace, W.width); // Find thinest trace
            } else {}
        }
    }
    
    pcbShopperTrace = u2mm(smallestTrace); // Convert internal units to mm
    pcbShopperTwUnits = mm;
    
    // Check hole sizes
    int smallestHole = INT_MAX; // Will lose to any other real hole
    
    board(B) { // Board context
        B.holes(H) { // Loop through board holes
            smallestHole = min(smallestHole, H.drill); // Find smallest drill
        }
        
        B.signals(S) {
            S.vias(V) {
                smallestHole = min(smallestHole, V.drill); // Find any via smaller than hole
            }
        }
        
        B.elements(E) { // Loop through each object on PCB
            E.package.contacts(C) { // Loop through each contact of each package
                if (C.pad) {
                    smallestHole = min(smallestHole, C.pad.drill); // Find contacts smaller than hole
                } else {}
            }
            
            E.package.holes(H) { // Loop through holes in each package
                smallestHole = min(smallestHole, H.drill); // Find holes smaller than others
            }
        }
    }
    
    pcbShopperDrill = u2mm(smallestHole); // Convert internal units to mm
    pcbShopperDrillUnits = mm;
    
    // Check for unrouted nets
    char ratsnestExist = false;
    
    board(B) { // Board context
        B.wires(W) { // Loop & check for unrouted wires
            if (W.layer == LAYER_UNROUTED) {
                ratsnestExist = true;
            } else {}
        }
        
        B.signals(S) {
            S.wires(W) { // Loop & check for unrouted signal wires
                if (W.layer == LAYER_UNROUTED) {
                    ratsnestExist = true;
                } else {}
            }
            
            S.polygons(P) { // Loop & check for unrouted polygons
                if (P.layer == LAYER_UNROUTED) {
                    ratsnestExist = true;
                } else {}
            }
        }
    }
    
    if (ratsnestExist == true) {
        paramWarnings += listWrap("There are unrouted nets on the PCB.");
    } else {}
    
    // Count hard gold finish pads (just the polygons and rectangles)
    char finishLayersUsed = false;
    pcbShopperFingers = 0;
    
    board(B) { // Board context
        // Check if either finish layer used
        B.layers(L) { // Loop through each layer
            if ((L.number == LAYER_TFINISH) || (L.number == LAYER_BFINISH)) {
                finishLayersUsed = true;
            } else {}
        }
        
        // Only run further counts if finish layers were used
        if (finishLayersUsed) {
            B.elements(E) { // Loop through each object
                E.package.polygons(P) { // Loop through each polygon of each package
                    if ((P.layer == LAYER_TFINISH) || (P.layer == LAYER_BFINISH)) {
                        pcbShopperFingers++;
                    } else {}
                }
                
                E.package.rectangles(R) { // Loop through each rectangle of each package
                    if ((R.layer == LAYER_TFINISH) || (R.layer == LAYER_BFINISH)) {
                        pcbShopperFingers++;
                    } else {}
                }
            }
            
            B.polygons(P) { // Loop through each polygon
                if ((P.layer == LAYER_TFINISH) || (P.layer == LAYER_BFINISH)) {
                    pcbShopperFingers++;
                } else {}
            }
            
            B.rectangles(R) { // Loop through each rectangle
                if ((R.layer == LAYER_TFINISH) || (R.layer == LAYER_BFINISH)) {
                    pcbShopperFingers++;
                } else {}
            }
            
            B.circles(C) { // Loop through each circle
                if ((C.layer == LAYER_TFINISH) || (C.layer == LAYER_BFINISH)) {
                    pcbShopperFingers++;
                } else {}
            }
        } else {}
    }
}


/**
 * Draw dialog with quote information
 * TODO
 */
void drawDialog(void) {
    string paramString;

    sprintf(paramString, "Width: %f, Height: %f, Layers: %d\nMin trace: %f, Min drill: %f, # fingers: %d",
                         pcbShopperWidth, pcbShopperHeight, pcbShopperLayers,
                         pcbShopperTrace, pcbShopperDrill, pcbShopperFingers);

    paramString += "\n" + paramWarnings;

    dlgMessageBox(paramString);
}


/*
 * Main function executed from here
 */

// Check we are in layout editor...
if (board) {
    status("Identifying PCB design constraints...");
    calculateParams(); // Check PCB for all relevant design constraints
    
    // Check if any warnings were generated during param calcs
    if (paramWarnings) {
        // Generate warning string for display
        paramWarnings = "<b>Warnings generated during param calcs:</b> <ul>" + paramWarnings + "</ul>";
    } else {}

    drawDialog(); // Display info dialog with params

    exit(EXIT_SUCCESS);

// If we are not in layout editor...
} else {
    // Popup warning
    dlgMessageBox("This script must be run from layout editor.");
}
